//
// **************************************************************
// * This is the modelling of the Birmingham Cyclotron Beamline *
// * including                                                  *
// * - the beampipe                                             *
// * - the mylar window                                         *
// * - the current chamber                                      *
// *                                                            *
// * Last updated Thu 21 Mar 2013 14:47:17 GMT (tprice)         *
// **************************************************************
//


#include "DetectorConstruction.hh"
#include "DetectorConstructionMessenger.hh"

#include "G4Material.hh"
#include "G4LogicalVolume.hh"
#include "G4ThreeVector.hh"
#include "G4RotationMatrix.hh"
#include "G4PVPlacement.hh"
#include "G4NistManager.hh"
#include "G4VisAttributes.hh"
#include "G4GeometryManager.hh"
#include "G4PhysicalVolumeStore.hh"
#include "G4LogicalVolumeStore.hh"
#include "G4UnitsTable.hh"

#include "G4SolidStore.hh"
#include "globals.hh"

#include "G4RunManager.hh"

DetectorConstruction::DetectorConstruction()
: expHall_log(0), 
  beampipe_log(0), 
  alcollimator_log(0), 
  havarwindow_log(0), 
  beampipe_vac_log(0),
  
  expHall_phys(0),
  beampipe_phys(0),
  alcollimator_phys(0),
  havarwindow_phys(0),
  beampipe_vac_phys(0)
{ 
	DefineMaterials();
 
  // DEFINE DEFAULT VALUES
	//absDepth = 100*mm;
	absorber_hz = 1*mm;
	absorber_material = Perspex;
  
  // create commands for interactive definition of the detector  
  detectorConstructionMessenger = new DetectorConstructionMessenger(this);  
}

DetectorConstruction::~DetectorConstruction()
{
	delete detectorConstructionMessenger;
}

G4VPhysicalVolume* DetectorConstruction::Construct()
{
	// DEFINE THE ACTUAL GEOMETRY
	// ==========================
	
	// Clean old geometry, if any
  //
  G4GeometryManager::GetInstance()->OpenGeometry();
  G4PhysicalVolumeStore::GetInstance()->Clean();
  G4LogicalVolumeStore::GetInstance()->Clean();
  G4SolidStore::GetInstance()->Clean();
	
	// world volume which holds everything
	// -----------------------------------
	G4double expHall_x = 0.25*m;
  G4double expHall_y = 0.25*m;
  G4double expHall_z = 2.00*m;
  expHall_box = new G4Box("expHall_box",               // name
                                 expHall_x,expHall_y,expHall_z); // size
  expHall_log = new G4LogicalVolume( expHall_box,                // solid
                                     Air,                        // material
                                     "experimentalHall_log" );   // name
  expHall_phys = new G4PVPlacement( 0,                           // no rotation
	                                  G4ThreeVector(),             // centre at (0,0,0)
	                                  expHall_log,                 // sits in experimentalHall logical volume
	                                  "experimentalHall",          // name
	                                  0,                           // no mother logical vol as world
	                                  false,                       // no copies
	                                  0 );                         // copy number = 0
	
	
	
	ConstructBeamline();
	// Jig to hold PMMA 
 	//ConstructJig();
 	
 	ConstructDynamiteSensor();
 	
 	return expHall_phys;
}



void DetectorConstruction::ConstructBeamline()
{
		
	//
	// some variables which will be used to calculate positions etc of the placements
	// ------------------------------------------------------------------------------
	
	// the beampipe
	beampipe_outerradius = 3.5*cm;
	beampipe_thickness   = 0.1*cm;
	beampipe_innerradius = beampipe_outerradius - beampipe_thickness;
	beampipe_hz          = 15.0*cm;
	beampipe_angle       = 0.*deg;
  beampipe_spanning    = 360.*deg;
  
  // the Al collimator within the end of the beampipe
	alcollimator_outerradius = beampipe_innerradius; // sits snuggly inside the beampipe
	alcollimator_innerradius = 0.5*cm;
	alcollimator_hz          = 3.347*cm;
	alcollimator_angle       = 0.0*deg;
	alcollimator_spanning    = 360.0*deg;
	
	// the Havar window at end of beampipe
	havarwindow_thickness   = 25*um;
  havarwindow_outerradius = alcollimator_innerradius+havarwindow_thickness;
  havarwindow_innerradius = alcollimator_innerradius;
  havarwindow_startingPhi = 0.0*deg;
  havarwindow_widthPhi    = 360.0*deg;
  havarwindow_startingEta = 90.0*deg;
  havarwindow_widthEta    = 90.0*deg;
  
  // Proton Monitor Chamber
  chamberposition_z     = 10*cm;
  chamber_startingangle = 0.0*deg;
  chamber_spanningangle = 360.0*deg;
  chamber_alring_outerradius   = 5.0*cm;
  chamber_alring_innerradius   = 4.0*cm;
  chamber_alring_hz            = 0.2*cm;
  chamber_airgap_outerradius = chamber_alring_innerradius;
  chamber_airgap_innerradius = 0.0*cm;
  chamber_airgap_hz          = 0.18*cm;
  chamber_window_outerradius = chamber_airgap_outerradius;
  chamber_window_innerradius = 0.0*cm;
  chamber_window_hz          = 0.002*cm;
    
  // PMMA absorber
  absorber_hx = 4.25*cm;
  absorber_hy = 4.75*cm;
  absorber_hz = absDepth/2;
  absorber_posz = chamberposition_z + chamber_alring_hz*2 + absorber_hz; // always so downstream face touches monitor
  
  G4cout << "\nAbsorber:"
  			<< "  Material = " << absorber_material  
  			<< "  Depth    = " << absDepth <<  G4endl << G4endl;
	     
 
  //
  // solids which will be used to define geometry
  // --------------------------------------------
 
  // beampipe tube
  beampipe_tube = new G4Tubs("beampipe_tube",           // name
                                     beampipe_innerradius,
                                     beampipe_outerradius,
                                     beampipe_hz,
                                     beampipe_angle,
                                     beampipe_spanning);
  
  // the Al collimator within the end of the beampipe
  alcollimator_tube = new G4Tubs("alcollimator_tube",
	                                       alcollimator_innerradius,
	                                       alcollimator_outerradius,
	                                       alcollimator_hz,
	                                       alcollimator_angle,
	                                       alcollimator_spanning);
	                                       
	// Havar window
  // Needs to be a hollow sphere but needs collimator removing  
  havarwindow_sphere = new G4Sphere("havarwindow_sphere",
                                     havarwindow_innerradius,
                                     havarwindow_outerradius,
                                     havarwindow_startingPhi,
                                     havarwindow_widthPhi,
                                     havarwindow_startingEta,
                                     havarwindow_widthEta);
                                     
  havarwindow_actual = new G4SubtractionSolid("havarwindow_actual",	
                                    havarwindow_sphere,
                                    alcollimator_tube);
  
  // Vacuum in beampipe
  beampipe_vac = ConstructBeampipeVacuum();
  
  // Beam monitor
  // needs a ring, airgap and two windows
  chamber_alring = new G4Tubs("chamber_alring",
                                        chamber_alring_innerradius,
                                        chamber_alring_outerradius,
                                        chamber_alring_hz,
                                        chamber_startingangle,
                                        chamber_spanningangle);
   chamber_airgap = new G4Tubs("chamber_airgap",
                                         chamber_airgap_innerradius,
                                         chamber_airgap_outerradius,
                                         chamber_airgap_hz,
                                         chamber_startingangle,
                                         chamber_spanningangle);
   chamber_window = new G4Tubs("chamber_window",
                                         chamber_window_innerradius,
                                         chamber_window_outerradius,
                                         chamber_window_hz,
                                         chamber_startingangle,
                                         chamber_spanningangle);                                   
  
  
  

  // PMMA absorber
  absorber = new G4Box("absorber",
                                absorber_hx,
                                absorber_hy,
                                absorber_hz);
                             											
  //
  // logical volumes
  // ---------------
 
  // beampipe
  beampipe_log = new G4LogicalVolume(beampipe_tube,
                                     Steel,
                                     "beampipe_log");
                                     
  // the Al collimator within the end of the beampipe 
  alcollimator_log = new G4LogicalVolume(alcollimator_tube,
	                                       Al,
	                                       "alcollimator_log");
	                                       
	// the Havar window
	havarwindow_log = new G4LogicalVolume(havarwindow_actual,
                                        Havar,
                                        "havarwindow_log");
	
	// the beampipe vacuum             
  beampipe_vac_log = new G4LogicalVolume(beampipe_vac,
                                        Vacuum,
                                        "beampipe_vac_log");
  
  // beamline monitor al ring, airgap, and window
  chamber_alring_log = new G4LogicalVolume(chamber_alring,
                                           Al,
                                           "chamber_alring_log");
                                           
  chamber_airgap_log = new G4LogicalVolume(chamber_airgap,
                                          Air,
                                          "chamber_airgap_log");
                                          
  chamber_window_log = new G4LogicalVolume(chamber_window,
                                          Kapton,
                                          "chamber_window");

  // PMMA absorber
  absorber_log = new G4LogicalVolume(absorber,
                                     absorber_material,
                                     "absorber_log");

  //
  // placements and physical volumes                                      
  // ----------
  
  // beampipe
  beampipe_phys = new G4PVPlacement(0,
                                    G4ThreeVector(0.0,0.0, -beampipe_hz), // set the end of beampipe at 0,0,0)
                                    beampipe_log,
                                    "beamPipe",
                                    expHall_log,
                                    false,
                                    0);
                                    
  // the Al collimator within the end of the beampipe
	alcollimator_phys = new G4PVPlacement(0,
                                        G4ThreeVector(0.0,0.0,-alcollimator_hz), // set end of collimator at z=0;
                                        alcollimator_log,
                                        "alCollimator",
                                        expHall_log,
                                        false,
                                        0);
  
  // the Havar window at end of beampipe                                     
  havarwindow_phys = new G4PVPlacement(0,
                                       G4ThreeVector(0.0,0.0,0.0),
                                       havarwindow_log,
                                       "havarWindow",
                                       expHall_log,
                                       false,
                                       0);
  
  // the beampipe vacuum volume
  beampipe_vac_phys = new G4PVPlacement(0,
                                       G4ThreeVector(0,0, -beampipe_hz),//+alcollimator_hz),
                                       beampipe_vac_log,
                                       "beampipeVacuum",
                                       expHall_log,
                                       false,
                                       0);
  
 
  // the Beam monitor consisting of al ring, airgap and windows  
  chamber_alring_phys = new G4PVPlacement(0,
                                          G4ThreeVector(0.0,0.0, +chamberposition_z),
                                          chamber_alring_log,
                                          "chamber_AlRing",
                                          expHall_log,
                                          false,
                                          0);   
   
   chamber_airgap_phys = new G4PVPlacement(0,
                                           G4ThreeVector(0.0,0.0, +chamberposition_z),
                                           chamber_airgap_log,
                                           "chamberAirGap",
                                           expHall_log,
                                           false,
                                           0);
                                           
   // need two windows so must place in seperate places
   chamber_window_phys1 = new G4PVPlacement(0,
                                            G4ThreeVector(0.0,0.0, +chamberposition_z + chamber_airgap_hz + chamber_window_hz),
                                            chamber_window_log,
                                            "chamberWindow1",
                                            expHall_log,
                                            true,
                                            0);
                                            
   chamber_window_phys2 = new G4PVPlacement(0,
                                            G4ThreeVector(0.0,0.0, +chamberposition_z - chamber_airgap_hz - chamber_window_hz),
                                            chamber_window_log,
                                            "chamberWindow2",
                                            expHall_log,
                                            true,
                                            1);
    
    

    // PMMA absorber
    absorber_phys = new G4PVPlacement(0,
                                      G4ThreeVector(0.0,0.0, +absorber_posz),
                                      absorber_log,
                                      "absorber",
                                      expHall_log,
                                      false,
                                      0);	
		
	//SDman = G4SDManager::GetSDMpointer();
  //absorber_sd = dynamic_cast<AbsorberSD*>(SDman->FindSensitiveDetector("absorber_sd",false));
  //if ( !absorber_sd ) {
  //  absorber_sd = new AbsorberSD("absorber_sd");
  //  SDman->AddNewDetector(absorber_sd);
  //}
  	
  //absorber_log->SetSensitiveDetector(absorber_sd);
  
 /* SDman = G4SDManager::GetSDMpointer();
  absorber_mfd = dynamic_cast<G4MultiFunctionalDetector*>(SDman->FindSensitiveDetector("absorber_mfd", false));
  if ( !absorber_mfd ) 
  {
  	absorber_mfd = new G4MultiFunctionalDetector("absorber_mfd");
  	SDman->AddNewDetector(absorber_mfd);
  }
  
  absorber_log->SetSensitiveDetector(absorber_mfd);
  
  absorber_fsf = new G4PSFlatSurfaceFlux("absorberSurfaceFlux",fFlux_In);
  absorber_edep = new G4PSEnergyDeposit("absorberEdep");
  
  absorber_mfd->RegisterPrimitive(absorber_fsf);
  absorber_mfd->RegisterPrimitive(absorber_edep);
	*/
	//SetVisAtt();

}	

void DetectorConstruction::SetAbsDepth(G4double value)
{
	absDepth = value;
}

G4double DetectorConstruction::GetAbsorberDepth()
{
	return absDepth; 
}

G4double DetectorConstruction::GetSensorPosition()
{ 
	G4double dynamite_z = dynamite_posz
											+ GetSensorDepth()/2;
	return dynamite_z;
}
   
G4double DetectorConstruction::GetSensorDepth()
{ 
	G4double totalDepth = dynamite_Si3N4_hz*2 
											+ dynamite_SiO2_hz*2 
											+ dynamite_epi_hz*2 
											+ dynamite_sub_hz*2;
	return totalDepth;
}

G4double DetectorConstruction::GetAbsorberPosition()
{
	return absorber_posz;
}

void DetectorConstruction::SetAbsMaterial(G4String material)
{
  //G4Material* pttoMaterial = G4Material::GetMaterial(material);  
  G4Material* pttoMaterial = G4NistManager::Instance()->FindOrBuildMaterial(material);
  if (pttoMaterial)
     {
     		G4cout << "### NEW MATERIAL SET TO " << material << G4endl;
     		//absorber_material = pttoMaterial;
     		absorber_log->SetMaterial(pttoMaterial); 
     		G4RunManager::GetRunManager()->PhysicsHasBeenModified();
     }  
  else {
  	G4cout << "### Cannot find material " << material << G4endl;
  }
}

G4double DetectorConstruction::GetBeamPipeInnerRadius()
{
	return beampipe_innerradius;
}

//G4String DetectorConstruction::GetAbsorberMaterial()
//{
//	return absorber_material;
//}

void DetectorConstruction::DefineMaterials()
{	
	// DEFINE ALL THE NECCESSARY MATERIALS
	// ===================================
	
	//G4double A(0);           // mass number
	//G4double Z(0);           // atomic number
	G4double density(0);     // material density
	G4int    ncomponents(0); // number of components in a material
	//G4int    natoms(0);      // number of atoms of each component in the material
	G4double fractionmass(0);// fractional mass of a component in a material
	
	G4NistManager* man = G4NistManager::Instance(); // allows materials to be accesses in the material database
	
	// Elements (Define as pure materials as easier to work with)
	// --------
	
	// silicon
	Si = man->FindOrBuildMaterial("G4_Si");	
	// aluminium
	Al = man->FindOrBuildMaterial("G4_Al");	
	// tantalum
	Ta = man->FindOrBuildMaterial("G4_Ta");
	// chrominium
	Cr = man->FindOrBuildMaterial("G4_Cr");
	// iron
	Fe = man->FindOrBuildMaterial("G4_Fe");
	// nickel
	Ni = man->FindOrBuildMaterial("G4_Ni");
	// oxygen
	O = man->FindOrBuildMaterial("G4_O");
	// carbon
	C = man->FindOrBuildMaterial("G4_C");
	// hydrogen
	H = man->FindOrBuildMaterial("G4_H");
	// nitrogen
	N = man->FindOrBuildMaterial("G4_N");
	// Manganese
	Mn = man->FindOrBuildMaterial("G4_Mn");
	// Molybdenum
	Mo = man->FindOrBuildMaterial("G4_Mo");
	// Tungsten
	W = man->FindOrBuildMaterial("G4_W");
	// Cobalt
	Co = man->FindOrBuildMaterial("G4_Mo");
	
	Be = man->FindOrBuildMaterial("G4_Be");
	
	
	// Compounds
	// ---------
	
	// water
	Water = man->FindOrBuildMaterial("G4_WATER");	
	// air
	Air = man->FindOrBuildMaterial("G4_AIR");	
	// vacuum (air but with a tiny density)
	Vacuum = man->FindOrBuildMaterial("G4_Galactic");	
	// stainless steel (to match fluka)
	Steel = new G4Material("Steel", density=8*g/cm3, ncomponents=3); 
	Steel->AddMaterial(Cr, fractionmass=0.18);
	Steel->AddMaterial(Fe, fractionmass=0.74);
	Steel->AddMaterial(Ni, fractionmass=0.08);
	// Mylar (to match fluka)
	Mylar = man->FindOrBuildMaterial("G4_MYLAR");
	//Mylar = new G4Material("Mylar", density=1.397*g/cm3, ncomponents=3);
	//Mylar->AddMaterial(H, fractionmass=0.3636);
	//Mylar->AddMaterial(C, fractionmass=0.45451);
	//Mylar->AddMaterial(O, fractionmass=0.1818);
	// Kapton (to match fluka)
	Kapton = new G4Material("Kapton", density=1.4*g/cm3, ncomponents=4);
	Kapton->AddMaterial(C, fractionmass=0.6911);
	Kapton->AddMaterial(H, fractionmass=0.0262);
	Kapton->AddMaterial(N, fractionmass=0.0733);
	Kapton->AddMaterial(O, fractionmass=0.2094);
	// Perspex
	Perspex = man->FindOrBuildMaterial("G4_PLEXIGLASS");
	/*Perspex = new G4Material("Perspex", density=1.19*g/cm3, ncomponents=3);
	Perspex->AddMaterial(C, fractionmass=0.33333);
	Perspex->AddMaterial(O, fractionmass=0.13333);
	Perspex->AddMaterial(H, fractionmass=0.53334);*/
	// Havar (to match fluka)
	Havar = new G4Material("Havar", density=8.3*g/cm3, ncomponents=8);
	Havar->AddMaterial(C,  0.9648*perCent);
	Havar->AddMaterial(Cr, 22.2858*perCent);
	Havar->AddMaterial(Mn, 1.6874*perCent);
	Havar->AddMaterial(Fe, 18.1139*perCent);
	Havar->AddMaterial(Co, 41.7828*perCent);
	Havar->AddMaterial(Ni, 12.8336*perCent);
	Havar->AddMaterial(Mo, 1.4494*perCent);
	Havar->AddMaterial(W,  0.8823*perCent);
	
	// Silicon Nitride
	Si3N4 = new G4Material("SiliconNitride", density=3.2*g/cm3, ncomponents=2);
	Si3N4->AddMaterial(Si, fractionmass=0.6);
	Si3N4->AddMaterial(N, fractionmass=0.4);
	
	SiO2 = man->FindOrBuildMaterial("G4_SILICON_DIOXIDE");

	G4cout << *(G4Material::GetMaterialTable()) << G4endl;
}

G4VSolid* DetectorConstruction::ConstructBeampipeVacuum()
{
// Beampipe needs to be filled with vacuum. Set a tube the same as 
  // outside of beampipe but minus away collimators and havar window volumes
  
  // define the three shapes which are on the inside of the beampip
  G4VSolid* beampipe_vac_tube = new G4Tubs("beampipe_vac_tube",           // name
                                     0.0,                              // solid tube
                                     beampipe_innerradius,
                                     beampipe_hz,//-alcollimator_hz,
                                     beampipe_angle,
                                     beampipe_spanning);  
                                     
  G4VSolid* beampipe_vac_sphere = new G4Sphere("havarwindow_sphere",
                                     0.0,
                                     havarwindow_outerradius,
                                     havarwindow_startingPhi,
                                     havarwindow_widthPhi,
                                     havarwindow_startingEta,
                                     havarwindow_widthEta);            
                                     
	// add the alcollimator inside and havar window inside together
	G4VSolid* beampipe_windowless = new G4SubtractionSolid("beampipe_windowless",
	                                   beampipe_vac_tube,
	                                   beampipe_vac_sphere,
	                                   0,
	                                   G4ThreeVector(0.0,0.0,+beampipe_hz));
	                                   
	// and add the end to the vac
	G4VSolid* beampipe_vac = new G4SubtractionSolid("beampipe_vac",
	                                   beampipe_windowless,
	                                   alcollimator_tube,
	                                   0,
	                                   G4ThreeVector(0.0,0.0,+beampipe_hz-alcollimator_hz));
	                                   
	return beampipe_vac;
}

G4VPhysicalVolume* DetectorConstruction::ConstructJig()
{
	// Jig
  // This will require 3 boxes to model correct shapes
  jig_outer_hx       = 5.25*cm;
  jig_outer_hy       = 8.5*cm;
  jig_outer_hz       = 5.75*cm;
  jig_hwallthickness = 0.5*cm;
  jig_airgap_hx      = jig_outer_hx - 2*jig_hwallthickness;
  jig_airgap_hy      = 5.5*cm;
  jig_airgap_hz      = jig_outer_hz;
  jig_posz           = chamberposition_z + chamber_alring_hz + jig_outer_hz;

// This will require 3 solids and some subtractions and additions
  G4VSolid* jig_volume = new G4Box("jig_volume",
                                   jig_outer_hx,
                                   jig_outer_hy,
                                   jig_outer_hz);
                                   
  G4VSolid* jig_air = new G4Box("jig_cutout",
                                 jig_airgap_hx, // airbox 2cm smaller in XY plane
                                 jig_airgap_hy,
                                 jig_airgap_hz);
  
  G4VSolid* jig_brace = new G4Box("jig_brace",
                                 jig_outer_hx - 2*jig_hwallthickness,
                                 jig_hwallthickness,
                                 jig_hwallthickness);
  
  // remove the brace from air volume                               
  G4VSolid* jig_minus_air = new G4SubtractionSolid("jig_minus_air",
                                 jig_volume,
                                 jig_air,
                                 0,
                                 G4ThreeVector(0,3.0*cm,0.0));
                                 
  G4VSolid* jig_frame = new G4UnionSolid("jig_frame",
                                 jig_minus_air,
                                 jig_brace,
                                 0,
                                 G4ThreeVector(0,jig_outer_hy-jig_hwallthickness,-jig_outer_hz+jig_hwallthickness));
  
  // PMMA Jig
  jig_log = new G4LogicalVolume(jig_frame,
                                Perspex,
                                "jig_log");
 	jig_phys = new G4PVPlacement(0,
                                 G4ThreeVector(0.0, -2.25*cm, +jig_posz),
                                 jig_log,
                                 "jig",
                                 expHall_log,
                                 false,
                                 0);
                                 
  return jig_phys;
}

void DetectorConstruction::ConstructDynamiteSensor()
{
	    // Dynamite sensor
    // Dynamite Sensor
  // Dynamite Sensor
  // silicon trackers
  dynamite_hx = 6*cm; 
  dynamite_hy = 6*cm; 
  dynamite_Si3N4_hz = 0.45*um;
  dynamite_SiO2_hz = 0.05*um;
  dynamite_epi_hz = 75*um;
  dynamite_sub_hz = 400*um;
  dynamite_back_hz = 2.5*mm;
  dynamite_seperation_abs = 22*cm; // the seperation between the tracker and the volume
  dynamite_posz = absorber_posz - absorber_hz + dynamite_seperation_abs; // place strip detectors 22 cm away from air monitor
	
	G4cout << "### Dynamite front face = "<< G4BestUnit(dynamite_posz, "Length") << G4endl;
  dynamite_Si3N4 = new G4Box("dynamite_Si3N4",
  												dynamite_hx,
  												dynamite_hy,
  												dynamite_Si3N4_hz);
  												
  dynamite_SiO2 = new G4Box("dynamite_SiO2",
  												dynamite_hx,
  												dynamite_hy,
  												dynamite_SiO2_hz);
  
  dynamite_epi = new G4Box("dynamite_epi",
  												dynamite_hx,
  												dynamite_hy,
  												dynamite_epi_hz);
  												
  dynamite_sub = new G4Box("dynamite_sub",
  												dynamite_hx,
  												dynamite_hy,
  												dynamite_sub_hz);
  												
  dynamite_back = new G4Box("dynamite_back",
  												dynamite_hx,
  												dynamite_hy,
  												dynamite_back_hz);	
  dynamite_Si3N4_log = new G4LogicalVolume(dynamite_Si3N4,
                                     Si3N4,
                                     "dynamite_Si3N4_log");
                                     
  dynamite_SiO2_log = new G4LogicalVolume(dynamite_SiO2,
                                     SiO2,
                                     "dynamite_SiO2_log");
                                                                        
  dynamite_epi_log = new G4LogicalVolume(dynamite_epi,
                                     Si,
                                     "dynamite_epi_log");
  
  dynamite_sub_log = new G4LogicalVolume(dynamite_sub,
                                     Si,
                                     "dynamite_sub_log");
                                     
	dynamite_back_log = new G4LogicalVolume(dynamite_back,
                                     Al,
                                     "dynamite_back_log");
    double dynamite_z = dynamite_posz;
    dynamite_Si3N4_phys = new G4PVPlacement(0,
    																	G4ThreeVector(0.0,0.0, dynamite_z),
    																	dynamite_Si3N4_log,
    																	"dynamite_Si3N4",
    																	expHall_log,
    																	false,
    																	0);
    
    dynamite_z += dynamite_Si3N4_hz + dynamite_SiO2_hz;
    dynamite_SiO2_phys = new G4PVPlacement(0,
    																	G4ThreeVector(0.0,0.0, dynamite_z),
    																	dynamite_SiO2_log,
    																	"dynamite_SiO2",
    																	expHall_log,
    																	false,
    																	0);
    																	
    dynamite_z += dynamite_SiO2_hz + dynamite_epi_hz;																	
    dynamite_epi_phys = new G4PVPlacement(0,
    																	G4ThreeVector(0.0,0.0, dynamite_z),
    																	dynamite_epi_log,
    																	"dynamite_epi",
    																	expHall_log,
    																	false,
    																	0);
   
   dynamite_z +=  dynamite_epi_hz	+dynamite_sub_hz	;										
   dynamite_sub_phys = new G4PVPlacement(0,
    																	G4ThreeVector(0.0,0.0, dynamite_z),
    																	dynamite_sub_log,
    																	"dynamite_sub",
    																	expHall_log,
    																	false,
    																	0); 
  
  dynamite_z +=   dynamite_sub_hz +dynamite_back_hz;															
  dynamite_back_phys = new G4PVPlacement(0,
    																	G4ThreeVector(0.0,0.0, dynamite_z),
    																	dynamite_back_log,
    																	"dynamite_back",
    																	expHall_log,
    																	false,
    																	0); 


}


void DetectorConstruction::SetVisAtt()
{
//                                        
  // Visualization attributes
  // ------------------------
  

// make world volume invisible  
  expHall_log->SetVisAttributes (G4VisAttributes::Invisible);

	// make the beampipe grey
  G4VisAttributes* beampipeVisAtt= new G4VisAttributes();
  beampipeVisAtt->SetVisibility(true);
  beampipeVisAtt->SetColor(G4Colour::Grey());
  beampipe_log->SetVisAttributes(beampipeVisAtt);
  
  // make the inside of the beampipe invisible
  G4VisAttributes* beampipevacVisAtt= new G4VisAttributes();
  beampipevacVisAtt->SetVisibility(false);
  beampipevacVisAtt->SetColor(G4Colour::White());
  beampipe_vac_log->SetVisAttributes(beampipevacVisAtt);
  
  // make the Al collimator white
  G4VisAttributes* alcolVisAtt = new G4VisAttributes();
  alcolVisAtt->SetVisibility(true);
  alcolVisAtt->SetColor(G4Colour::Red());
  alcollimator_log->SetVisAttributes(alcolVisAtt);
	
	// make havar window yellow to see it
  G4VisAttributes* havarwindowVisAtt = new G4VisAttributes();
  havarwindowVisAtt->SetVisibility(true);
  havarwindowVisAtt->SetColor(G4Colour::Yellow());
  havarwindow_log->SetVisAttributes(havarwindowVisAtt);
  
  // make chamber windows orange like real life
  G4VisAttributes* chamberwindowVisAtt = new G4VisAttributes();
  chamberwindowVisAtt->SetVisibility(true);
  chamberwindowVisAtt->SetColor(G4Colour(1.,0.5,0.));
  chamber_window_log->SetVisAttributes (chamberwindowVisAtt);
  
  // 
  chamber_airgap_log->SetVisAttributes (G4VisAttributes::Invisible);
  
  // ring is made grey to mimic the metal
  G4VisAttributes* chamberringVisAtt = new G4VisAttributes();
  chamberringVisAtt->SetVisibility(true);
  chamberringVisAtt->SetColor(G4Colour::Gray());
  chamber_alring_log->SetVisAttributes (chamberringVisAtt);
  
  G4VisAttributes* jigVisAtt = new G4VisAttributes();
  jigVisAtt->SetVisibility(true);
  jigVisAtt->SetColor(G4Colour::Green());
  jig_log->SetVisAttributes(jigVisAtt);
  
  // PMMA absorber 
  G4VisAttributes* absorberVisAtt = new G4VisAttributes();
  absorberVisAtt->SetVisibility(true);
  absorberVisAtt->SetColor(G4Colour::Blue());
  absorber_log->SetVisAttributes(absorberVisAtt);
  
  G4VisAttributes* dynamiteBackVisAtt = new G4VisAttributes();
  dynamiteBackVisAtt->SetVisibility(true);
  dynamiteBackVisAtt->SetColor(G4Colour::Grey());
  dynamite_back_log->SetVisAttributes(dynamiteBackVisAtt);

}

void DetectorConstruction::UpdateGeometry()
{
  G4RunManager::GetRunManager()->DefineWorldVolume(Construct());
}
